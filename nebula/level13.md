Let's take a look at the code...

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <string.h>

#define FAKEUID 1000

int main(int argc, char **argv, char **envp)
{
  int c;
  char token[256];

  if(getuid() != FAKEUID) {
      printf("Security failure detected. UID %d started us, we expect %d\n", getuid(), FAKEUID);
      printf("The system administrators will be notified of this violation\n");
      exit(EXIT_FAILURE);
  }

  // snip, sorry :)

  printf("your token is %s\n", token);
  
}
```

So looking at this code, it appears that thus program checks your user id using getuid(), then if it matches it prints a token which you can use to authenticate as the user flag13.
There are several different ways we could exploit this. We could jump through some hoops to trick the getuid() into thinking our user id is 100. We could open the binary up in a hex editor and change the value it is looking for. I am just going to try and solve it in gdb.

```
$ cd /home/flag13
$ gdb ./flag13
```

and now let's view the dissassembly code for the main function

```
(gdb) disas main
```

When we look at the wall of text that is the dissassembly, pretty close to the start at +48 (memory address 0x080484f4) that is a cmp command. Whenever you see cmp in dissassembly, that means that it is comparing two thing to evaluate a condition (they are almost alway used in if then statements). Looking at the source code, there is only one if then statement (or really anything else that would call for a cmp instruction, like a while or for loop) so we can be pretty confident that that is the instruction we are looking for. To make sure I browsed through the rest of the assembly and couldn't find any other cmp instructions.

```
0x080484f4  <+48>:    cmp   $0x3e8,%eax
```

So this command is comparing the the eax register (registers are just temporary memory storage units for the cpu) to the hex value0x3e8 which is equivalent to 1000. What we can do is we can set a breakpoint for that instruction, then change the value of the eax register so the condition becomes true and it outputs the token.

```
(gdb) break *main+48
Breakpoint 1 at 0x80484f4
(gdb) run
Starting program: /home/flag13/flag13

Breakpoint 1, 0x80484f4 in main ()
(gdb) set $eac = 1000
(gdb) continue
Continuing.
your token is b705702b-76a8-42b0-8844-3adabbe5ac58
[Inferior 1 (process 2422) exited with code 063]
(gdb) quit
```

And it worked, we were able to extract the token in gdb. Now to login as the user flag13 and finish this.

```
$ su flag13
Password: b705702b-76a8-42b0-8844-3adabbe5ac58
sh-4.2$ getflag
You have successfully executed getflag on a target account
```

And just like that we pwned the binary.



