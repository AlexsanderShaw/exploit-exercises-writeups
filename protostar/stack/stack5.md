Let's take a lood at the source code...

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

So at only 11 lines of code, this program doesn't give us alot to work with. It just establishes a 64 character buffer, and takes input using an insecure gets() command.
However what we could possibly do is insert shellcode (which is just precompiled assembly instructions for a certain task) into the program, then override the eip register (which stores the return address) to execute the shell code. Let's open it up in gdb to see where the eip register is stored, and where our input starts.

```
root@protostar:/opt/protostar/bin# gdb ./stack5
```

One wall of text later...

```
(gdb) disas main
Dump of assembler code for function main:
   0x080483c4 <+0>:	push   %ebp
   0x080483c5 <+1>:	mov    %esp,%ebp
   0x080483c7 <+3>:	and    $0xfffffff0,%esp
   0x080483ca <+6>:	sub    $0x50,%esp
   0x080483cd <+9>:	lea    0x10(%esp),%eax
   0x080483d1 <+13>:	mov    %eax,(%esp)
   0x080483d4 <+16>:	call   0x80482e8 <gets@plt>
   0x080483d9 <+21>:	leave  
   0x080483da <+22>:	ret    
End of assembler dump.b *main+16
(gdb) b *main+21
Breakpoint 1 at 0x80483d9: file stack5/stack5.c, line 11.
(gdb) r
Starting program: /Hackery/ctf/protostar/stack5 
000000000000000000000000000000000000000000

Breakpoint 1, main (argc=1, argv=0xffffd124) at stack5/stack5.c:11
11	in stack5/stack5.c
(gdb) info frame
```
And now, the eip register
```
Saved registers:
  ebp at 0xbffffd28, eip at 0xbffffd2c
```

So we have the eip register location, which is 0xffffd08c. Now we just need to find where our input is stored. Looking back at the assembly, we can see that the eax register is pushed onto the stack before it makes the gets() call. SInce we are at a breakpoint, we can just take a look in there.

```
(gdb) x/12 $eax
0xbffffce0:	0x30303030	0x30303030	0x30303030	0x30303030
0xbffffcf0:	0x30303030	0x30303030	0x30303030	0x30303030
0xbffffd00:	0x30303030	0x30303030	0x08003030	0xbffffd28
```

When we originally ran the program, we gave it a lot of zeros for input. 42 to be percise. 0 in hex is 0x30. Looking at the output for the eax register, we can see 42 "30"s, so we must be looking at the entirety of our input; and it starts at 0xffffd040. So now to figure out the distance between the eip register, and the start of our input.

```
>>> 0xffffd08c - 0xffffd040 = 76
```

So we have 76 bytes untill we hit the eip register. This means that we have 76 bytes for our shellcode. Since this challenge doesn't have a flag or anything, you can do whatever you want with your shellcode. I'm going to pop a shell.

First we need to find shellcode that does what we want, fits within our constraints, and is compatible with our system. The link below is a good place to go if you are looking for shellcode. 
You should probably pick something under the "Intel x86" (Also called on the site Linux/x86) section. I tried several different shellcode elsewhere and they didn't seem to work.

http://shell-storm.org/shellcode/

I used the Linux/x86 execve /bin/sh shellcode 23 bytes by Hamza Megahed. (http://shell-storm.org/shellcode/files/shellcode-827.php)

For the previous challenges, we just piped in a string to the program which pwned it. Here since we are dealing with shellcode, I'm going to generate the payload on my host, and transfer it over using netcat

On the Host:
```

```

























